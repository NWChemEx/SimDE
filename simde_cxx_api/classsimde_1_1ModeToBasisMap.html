<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simde: simde::ModeToBasisMap&lt; BasisSetType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>simde</b></li><li class="navelem"><a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsimde_1_1ModeToBasisMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">simde::ModeToBasisMap&lt; BasisSetType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores a mapping from mode index to basis set instances.  
 <a href="classsimde_1_1ModeToBasisMap.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mode__to__basis__map_8hpp_source.html">mode_to_basis_map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a28a7398dbe76f34deb66e49f9981eae3"><td class="memItemLeft" align="right" valign="top"><a id="a28a7398dbe76f34deb66e49f9981eae3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a28a7398dbe76f34deb66e49f9981eae3">mode_type</a> = unsigned int</td></tr>
<tr class="memdesc:a28a7398dbe76f34deb66e49f9981eae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing modes, acts like an unsinged integer type. <br /></td></tr>
<tr class="separator:a28a7398dbe76f34deb66e49f9981eae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0022fce73f15acb13c22c51d033fc48"><td class="memItemLeft" align="right" valign="top"><a id="af0022fce73f15acb13c22c51d033fc48"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#af0022fce73f15acb13c22c51d033fc48">basis_set_type</a> = BasisSetType</td></tr>
<tr class="memdesc:af0022fce73f15acb13c22c51d033fc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unqualified type of a basis set instance, typedef of BasisSetType. <br /></td></tr>
<tr class="separator:af0022fce73f15acb13c22c51d033fc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4c398c8dff0e9205026a8f5b26bb80"><td class="memItemLeft" align="right" valign="top"><a id="a9f4c398c8dff0e9205026a8f5b26bb80"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a9f4c398c8dff0e9205026a8f5b26bb80">const_basis_set_reference</a> = const_ref_wrapper&lt; BasisSetType &gt;</td></tr>
<tr class="memdesc:a9f4c398c8dff0e9205026a8f5b26bb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only reference to a basis set, typedef of const BasisSetType&amp;. <br /></td></tr>
<tr class="separator:a9f4c398c8dff0e9205026a8f5b26bb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4c44bcb5b83fcd61bb8a3f86c5c7aa"><td class="memItemLeft" align="right" valign="top"><a id="a4a4c44bcb5b83fcd61bb8a3f86c5c7aa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a4a4c44bcb5b83fcd61bb8a3f86c5c7aa">map_type</a> = std::map&lt; <a class="el" href="classsimde_1_1ModeToBasisMap.html#a28a7398dbe76f34deb66e49f9981eae3">mode_type</a>, <a class="el" href="classsimde_1_1ModeToBasisMap.html#a9f4c398c8dff0e9205026a8f5b26bb80">const_basis_set_reference</a> &gt;</td></tr>
<tr class="memdesc:a4a4c44bcb5b83fcd61bb8a3f86c5c7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::map from mode offest to const_basis_set_reference. <br /></td></tr>
<tr class="separator:a4a4c44bcb5b83fcd61bb8a3f86c5c7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d87984cb2e892944978f391ebbf705"><td class="memItemLeft" align="right" valign="top"><a id="a30d87984cb2e892944978f391ebbf705"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a30d87984cb2e892944978f391ebbf705">const_reference</a> = typename map_type::const_reference</td></tr>
<tr class="memdesc:a30d87984cb2e892944978f391ebbf705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only reference to a "mode, basis set" pair. <br /></td></tr>
<tr class="separator:a30d87984cb2e892944978f391ebbf705"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a23f8ccfb1d1689875047babd672929d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a23f8ccfb1d1689875047babd672929d5">ModeToBasisMap</a> ()=default</td></tr>
<tr class="memdesc:a23f8ccfb1d1689875047babd672929d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instance.  <a href="classsimde_1_1ModeToBasisMap.html#a23f8ccfb1d1689875047babd672929d5">More...</a><br /></td></tr>
<tr class="separator:a23f8ccfb1d1689875047babd672929d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fe0a25ea453c81e194ad1c617c05d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a58fe0a25ea453c81e194ad1c617c05d4">ModeToBasisMap</a> (const <a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;other)</td></tr>
<tr class="memdesc:a58fe0a25ea453c81e194ad1c617c05d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>other</code>.  <a href="classsimde_1_1ModeToBasisMap.html#a58fe0a25ea453c81e194ad1c617c05d4">More...</a><br /></td></tr>
<tr class="separator:a58fe0a25ea453c81e194ad1c617c05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e2b4b9083e39cba6905edfaeb0f635"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a24e2b4b9083e39cba6905edfaeb0f635">ModeToBasisMap</a> (<a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a24e2b4b9083e39cba6905edfaeb0f635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> by taking ownership of <code>other</code>.  <a href="classsimde_1_1ModeToBasisMap.html#a24e2b4b9083e39cba6905edfaeb0f635">More...</a><br /></td></tr>
<tr class="separator:a24e2b4b9083e39cba6905edfaeb0f635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06598bbfea285c4b9236abeb8e40dee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a06598bbfea285c4b9236abeb8e40dee2">operator=</a> (const <a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;rhs)</td></tr>
<tr class="memdesc:a06598bbfea285c4b9236abeb8e40dee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the current instance a deep copy of <code>rhs</code>.  <a href="classsimde_1_1ModeToBasisMap.html#a06598bbfea285c4b9236abeb8e40dee2">More...</a><br /></td></tr>
<tr class="separator:a06598bbfea285c4b9236abeb8e40dee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe60d921457002ebbd35f80336a2a18b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#abe60d921457002ebbd35f80336a2a18b">operator=</a> (<a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:abe60d921457002ebbd35f80336a2a18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of <code>rhs</code>.  <a href="classsimde_1_1ModeToBasisMap.html#abe60d921457002ebbd35f80336a2a18b">More...</a><br /></td></tr>
<tr class="separator:abe60d921457002ebbd35f80336a2a18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34058901c8dc471ee76a5b7f4d6f61"><td class="memItemLeft" align="right" valign="top"><a id="a2e34058901c8dc471ee76a5b7f4d6f61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;other) noexcept</td></tr>
<tr class="separator:a2e34058901c8dc471ee76a5b7f4d6f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18241b8deb40c8357390b94240fde418"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a18241b8deb40c8357390b94240fde418">size</a> () const noexcept</td></tr>
<tr class="memdesc:a18241b8deb40c8357390b94240fde418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mode-to-basis-set mappings.  <a href="classsimde_1_1ModeToBasisMap.html#a18241b8deb40c8357390b94240fde418">More...</a><br /></td></tr>
<tr class="separator:a18241b8deb40c8357390b94240fde418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ab94f48f8880035c4c870d12e762ba"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a60ab94f48f8880035c4c870d12e762ba">count</a> (<a class="el" href="classsimde_1_1ModeToBasisMap.html#a28a7398dbe76f34deb66e49f9981eae3">mode_type</a> i) const noexcept</td></tr>
<tr class="memdesc:a60ab94f48f8880035c4c870d12e762ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times a mode offset appears in the map.  <a href="classsimde_1_1ModeToBasisMap.html#a60ab94f48f8880035c4c870d12e762ba">More...</a><br /></td></tr>
<tr class="separator:a60ab94f48f8880035c4c870d12e762ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114d8be059958229e9a2d98ecc373a1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a114d8be059958229e9a2d98ecc373a1b">emplace</a> (<a class="el" href="classsimde_1_1ModeToBasisMap.html#a28a7398dbe76f34deb66e49f9981eae3">mode_type</a> i, <a class="el" href="classsimde_1_1ModeToBasisMap.html#a9f4c398c8dff0e9205026a8f5b26bb80">const_basis_set_reference</a> bs)</td></tr>
<tr class="memdesc:a114d8be059958229e9a2d98ecc373a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified "mode offset, basis set" pair to the map.  <a href="classsimde_1_1ModeToBasisMap.html#a114d8be059958229e9a2d98ecc373a1b">More...</a><br /></td></tr>
<tr class="separator:a114d8be059958229e9a2d98ecc373a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810078ee4270ba3ad878a996ae80955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a9f4c398c8dff0e9205026a8f5b26bb80">const_basis_set_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a5810078ee4270ba3ad878a996ae80955">at</a> (<a class="el" href="classsimde_1_1ModeToBasisMap.html#a28a7398dbe76f34deb66e49f9981eae3">mode_type</a> i) const</td></tr>
<tr class="memdesc:a5810078ee4270ba3ad878a996ae80955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the basis set for the i-th mode of the tensor.  <a href="classsimde_1_1ModeToBasisMap.html#a5810078ee4270ba3ad878a996ae80955">More...</a><br /></td></tr>
<tr class="separator:a5810078ee4270ba3ad878a996ae80955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16606aa475efe9beb7cdb3579386ca55"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a16606aa475efe9beb7cdb3579386ca55">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a16606aa475efe9beb7cdb3579386ca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first "mode, basis set" pair.  <a href="classsimde_1_1ModeToBasisMap.html#a16606aa475efe9beb7cdb3579386ca55">More...</a><br /></td></tr>
<tr class="separator:a16606aa475efe9beb7cdb3579386ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78b81c693b88a359a9936cfec15055a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#af78b81c693b88a359a9936cfec15055a">end</a> () const noexcept</td></tr>
<tr class="memdesc:af78b81c693b88a359a9936cfec15055a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to just past the last mode-basis set pair.  <a href="classsimde_1_1ModeToBasisMap.html#af78b81c693b88a359a9936cfec15055a">More...</a><br /></td></tr>
<tr class="separator:af78b81c693b88a359a9936cfec15055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5adcdb73c47ce200108c7e87125aca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#abf5adcdb73c47ce200108c7e87125aca">operator==</a> (const <a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:abf5adcdb73c47ce200108c7e87125aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instances for value equality.  <a href="classsimde_1_1ModeToBasisMap.html#abf5adcdb73c47ce200108c7e87125aca">More...</a><br /></td></tr>
<tr class="separator:abf5adcdb73c47ce200108c7e87125aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c98890bd39f54d8ffdb6546d98331b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a5c98890bd39f54d8ffdb6546d98331b4">operator!=</a> (const <a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a5c98890bd39f54d8ffdb6546d98331b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instances are different.  <a href="classsimde_1_1ModeToBasisMap.html#a5c98890bd39f54d8ffdb6546d98331b4">More...</a><br /></td></tr>
<tr class="separator:a5c98890bd39f54d8ffdb6546d98331b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename BasisSetType&gt;<br />
class simde::ModeToBasisMap&lt; BasisSetType &gt;</h3>

<p>Stores a mapping from mode index to basis set instances. </p>
<p>This class is primarily meant for use with the property types associated with tensor representations. When we call a module satisfying one of those property types we must specify the basis sets for each mode of the tensor. This is conventionally done by positional arguments (0-th basis set passed in is for mode 0, 1-st is for mode 1, etc.), but that leads to a lot of APIs (templating doesn't really help because property types/modules require you to explicitly instantiate a template per permuation of types).</p>
<p>Our solution is to introduce the <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> class. This class acts like a std::map&lt;int, const BasisSetType&amp;&gt; where the keys are mode indices and the values are read-only references to BasiSetType instances. Using the <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> class property types are defined in terms of number of basis sets (i.e., the rank of the resulting tensor) and a series of ModeToBasisMap&lt;T&gt; instances, one <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instance for each basis set T the module needs to consider.</p>
<p>In practice the <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> class is a thin wrapper around a std::map, which also worries about ownership. In particular since this class is meant for use with property types it recognizes that it sometimes must alias the basis sets and other times own them. The logic for this is encapsulated in copy vs move; copy deep copies instances whereas move preserves aliasing.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasisSetType</td><td>The type being used to model a basis set. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a23f8ccfb1d1689875047babd672929d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f8ccfb1d1689875047babd672929d5">&#9670;&nbsp;</a></span>ModeToBasisMap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::<a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instance. </p>
<p>This ctor creates a <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instance which contains no elements yet. Elements can be added by calling emplace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58fe0a25ea453c81e194ad1c617c05d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fe0a25ea453c81e194ad1c617c05d4">&#9670;&nbsp;</a></span>ModeToBasisMap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::<a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a>&lt; BasisSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of <code>other</code>. </p>
<p>This function will own deep copies of each basis set in <code>other</code>. This means regardless of whether or not <code>other</code> aliased a basis set, the resulting <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> will own its copy. The basis sets will still have the same mapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The instance being deep-copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the copy fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e2b4b9083e39cba6905edfaeb0f635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e2b4b9083e39cba6905edfaeb0f635">&#9670;&nbsp;</a></span>ModeToBasisMap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::<a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a>&lt; BasisSetType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> by taking ownership of <code>other</code>. </p>
<p>This ctor creates a new instance by moving the state from <code>other</code> to the new instance. In particular this means the new instance will still alias any basis sets <code>other</code> aliased, and it will own any basis sets that <code>other</code> owned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The instance whose state is being transferred to the newly created <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instance. After the operation <code>other</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5810078ee4270ba3ad878a996ae80955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5810078ee4270ba3ad878a996ae80955">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a9f4c398c8dff0e9205026a8f5b26bb80">const_basis_set_reference</a> <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a28a7398dbe76f34deb66e49f9981eae3">mode_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the basis set for the i-th mode of the tensor. </p>
<p>This method is used to look up registered mode to basis set mappings. Given mode offset <code>i</code>, this method will return the basis set <code>bs</code> that was inserted as if by calling <code>emplace(i, bs)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The tensor mode we are retrieving the basis set for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the basis set for the <code>i</code> -th mode.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>i</code> is not associated with a basis set in this instance. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16606aa475efe9beb7cdb3579386ca55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16606aa475efe9beb7cdb3579386ca55">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first "mode, basis set" pair. </p>
<p>This method returns an iterator which points to the first "mode, basis
set" pair. In particular note this iterator runs over more than just the keys of the map. The actual instance pointed to behaves like <code>std::pair&lt;mode_type, const_basis_set_reference&gt;</code>.</p>
<p>N.B. If <code><a class="el" href="classsimde_1_1ModeToBasisMap.html#a18241b8deb40c8357390b94240fde418" title="Returns the number of mode-to-basis-set mappings.">size()</a>==0</code> the iterator returned by this method is the same as the one returned by <code><a class="el" href="classsimde_1_1ModeToBasisMap.html#af78b81c693b88a359a9936cfec15055a" title="Returns an iterator to just past the last mode-basis set pair.">end()</a></code> and should NOT be dereferenced.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first mode-bs pair.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60ab94f48f8880035c4c870d12e762ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ab94f48f8880035c4c870d12e762ba">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a28a7398dbe76f34deb66e49f9981eae3">mode_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of times a mode offset appears in the map. </p>
<p>This method will count the number of pairs which have a mode offset of <code>i</code>. Since at most only one pair can have such an offset this function always return 0 or 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The offset we are looking for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True (1) if the instance contains <code>i</code> and false (0) otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a114d8be059958229e9a2d98ecc373a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114d8be059958229e9a2d98ecc373a1b">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a28a7398dbe76f34deb66e49f9981eae3">mode_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsimde_1_1ModeToBasisMap.html#a9f4c398c8dff0e9205026a8f5b26bb80">const_basis_set_reference</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified "mode offset, basis set" pair to the map. </p>
<p>This method is used to associate the <code>i</code> -th mode of the tensor with basis set <code>bs</code>. If this instance already has a mapping for mode offset <code>i</code> then this is a no-op.</p>
<dl class="section note"><dt>Note</dt><dd>the don't overwrite behavior is consistent with emplace on std::map.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The tensor mode to associate <code>bs</code> with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bs</td><td>The basis set to associate with the <code>i</code> -th mode of the tensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem storing the pair. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af78b81c693b88a359a9936cfec15055a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78b81c693b88a359a9936cfec15055a">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to just past the last mode-basis set pair. </p>
<p>This method is used to retrieve an iterator that points to just past the last "mode offset, basis set" pair. The iterator should be considered a semaphore and should NOT be dereferenced.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator which points to just past the last mode-basis set pair. This iterator should not be dereferenced.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c98890bd39f54d8ffdb6546d98331b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c98890bd39f54d8ffdb6546d98331b4">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a>&lt; BasisSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instances are different. </p>
<p>This method negates operator==. See operator== for a definition of equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if this compares equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06598bbfea285c4b9236abeb8e40dee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06598bbfea285c4b9236abeb8e40dee2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a>&amp; <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a>&lt; BasisSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the current instance a deep copy of <code>rhs</code>. </p>
<p>This method will overwrite the current instance's state with a deep copy of the state found in <code>rhs</code>. Similar to the copy ctor, the resulting instance will own deep copies of each basis set regardless of whether or not <code>rhs</code> aliased or owned the basis sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state is being copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance, after setting its state to a deep copy of <code>rhs</code> 's state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the copy fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe60d921457002ebbd35f80336a2a18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe60d921457002ebbd35f80336a2a18b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a>&amp; <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a>&lt; BasisSetType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of <code>rhs</code>. </p>
<p>This method will release the state currenting held in the present instance and replace it with the state held in <code>rhs</code>. This means that after this call the present instance will alias the basis sets that <code>rhs</code> aliased and own the basis sets that <code>rhs</code> owned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instance we are taking ownership of. After this call <code>rhs</code> will be in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance, after setting its state to a deep copy of <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf5adcdb73c47ce200108c7e87125aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5adcdb73c47ce200108c7e87125aca">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsimde_1_1ModeToBasisMap.html">ModeToBasisMap</a>&lt; BasisSetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instances for value equality. </p>
<p>This method is used to determine if two <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instances map the same modes to the same basis sets. In particular we compare the values of the basis sets, not the addresses. In other words, if <code>x</code> and <code>y</code> are two basis set instances such that <code>x == y</code>, but <code>&amp;x != &amp;y</code> then a mapping from mode <code>i</code> to an alias of <code>x</code> in one <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instance will compare equal to a mapping from mode <code>i</code> to an alias of <code>y</code> in another <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instance. Whether the <a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instances own or alias their values is not considered in the comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this instance compares equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18241b8deb40c8357390b94240fde418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18241b8deb40c8357390b94240fde418">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisSetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsimde_1_1ModeToBasisMap.html">simde::ModeToBasisMap</a>&lt; BasisSetType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of mode-to-basis-set mappings. </p>
<p><a class="el" href="classsimde_1_1ModeToBasisMap.html" title="Stores a mapping from mode index to basis set instances.">ModeToBasisMap</a> instances are essentially maps from mode offsets to the basis set for that mode. This function will return the number of such mappings contained within the current instance.</p>
<p>It should be noted that for a mode <code>i</code>, <code>i &lt; <a class="el" href="classsimde_1_1ModeToBasisMap.html#a18241b8deb40c8357390b94240fde418" title="Returns the number of mode-to-basis-set mappings.">size()</a></code> does not guarantee that <code>i</code> is a valid key nor does <code>i &gt;= <a class="el" href="classsimde_1_1ModeToBasisMap.html#a18241b8deb40c8357390b94240fde418" title="Returns the number of mode-to-basis-set mappings.">size()</a></code> guarantee that <code>i</code> is an invalid key. For example,</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> O_imnj = tensor_representation(i, mu, O, nu, j);</div>
</div><!-- fragment --><p>will result in two maps (assuming "i" and "j" are DerivedSpace objects and "mu" and "nu" are AOSpace objects):</p>
<ul>
<li>ModeToBasis&lt;DerivedSpace&gt;{{0, i}, {3, j}} (size 2)</li>
<li>ModeToBasis&lt;AOSpace&gt;{{1, mu}, {2, nu}} (size 2)</li>
</ul>
<p>Mode 0 is an invalid input for the second map (despite being less than <code><a class="el" href="classsimde_1_1ModeToBasisMap.html#a18241b8deb40c8357390b94240fde418" title="Returns the number of mode-to-basis-set mappings.">size()</a></code>) and mode 3 is a valid input for first map (despite being more than <code><a class="el" href="classsimde_1_1ModeToBasisMap.html#a18241b8deb40c8357390b94240fde418" title="Returns the number of mode-to-basis-set mappings.">size()</a></code>).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of mode-to-basis-set mappings in the instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/simde/tensor_representation/<a class="el" href="mode__to__basis__map_8hpp_source.html">mode_to_basis_map.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
